01
02
03
04
05 For, While Platzhalterstrings
06 Methods, enum, zip
07 Automaton 16.12.
08 Dicts, Files sorting
09 Class,  16.12.

10 Repetition. 06.1.
11 Test, 13.1. Canvas, Widgets
12 Callbacks
13 Games, Projectarbeit infos, Themen fixieren.

14 PA 17.2.
15 PA
16 PA
17 Projectvorstellung
18

Damit Bilder gefunden werden:
/home/studi/work$ ln -s .src/images images

Aufraeumen: Verschiebe was wir behandelt haben nach L05
dann update 6, overwrite y

Letztes Mal: 
- range, slicenotation, Platzhalterstings und Formatierungsspezifikationen
- While-Loop, 
 

Kontrollfragen_05A
  range, slice, Platzhalter
  einige Standardprobleme mit Funktionen programmieren, 
  maxlen fuer  Ausgabe der Tabelle in 10) benoetigt.

For und While, Aufgabe:
========================================

def eval_guess(guess, secret):
    '''returns a tuple (ok, i),
       ok is guess == secret, and i is -1,0 or 1 depending on whether
       guess is too small, correct or too big
       guess: int
       secret: int
    '''
    if guess == secret:
        return (True, 0)
    if guess < secret:
        return (False, -1)
    if guess > secret:
       return (False, 1)

Trick:
comments = ['richtig', 'zu gross', 'zu klein']
comments[-1]

secret = 3
guess = 1
comments = ['richtig', 'zu gross', 'zu klein']
ok, i = eval_guess(guess, secret)
ok, comments[i]


def next_guess(guess, evaluation, lower, upper):
    # neue Grenzen bestimmen
    if evaluation == 1:
        upper = guess - 1
    else:
        lower = guess + 1
    # neuer Guess in der Mitte von lower und upper
    n = (lower + upper) // 2
    return n, lower, upper

lower, upper = 0, 10
secret = 4
guess = 7
e = 1  # guess zu gross

guess, lower, upper = next_guess(guess, e, lower, upper)
ok, e = eval_guess(guess, secret)

str.format('guess={}, eval={}, lower={}, upper={}',
           guess, comments[e], lower, upper)


---
lower, upper = 0, 10
secret = 4
guess = (lower + upper) // 2
attempts = 0

while True:
    attempts = attempts + 1
    ok, e = eval_guess(guess, secret)
    msg = str.format('{} ist {}', guess, comments[e])
    print(msg)
    if ok:
        print('Versuche:', attempts)
        break
    guess, lower, upper = next_guess(guess, e, lower, upper)


Der Unpacking-Operator *, Teil II, variadic Functions Coding range by hand 
=========================

def f(*args):
    print('Anzahl Argumente: {}'.format(len(arg)))
    print(*args)

Eigene Implementation der range Funktion:
def f(*args):
    start = 0
    step = 1
    if len(args) == 1:
        stop, = args
    elif len(args) == 2:
        ...
    elif len(args) == 3:  
        ...
    else:
        raise Exception('at most 3 arguments expected')
    # Ausgabe von start, stop, step
Notebook: 
Eigene Implementation der range Funktion:


Variabeln, Objekte, Referenzen
Gehe langsam gemeinsam durch, 
Listenrefs auf Pythontutor.


Type_Methoden
read Docstring of str.join: 

s = ' und '
words = ['Haus', 'Hof', 'Kind']
s.join(words)

The string whose method is called ...

list.append()
numbers = [1,2,3]
numbers.append(4)
numbers

numbers.pop()

liste_mit_listen
================



enumerate und zip und for/while else

word = 'abc'
enumerate(word)

tuple(enumerate(word))

nbrs = (1, 2, 3)
zip(numbers, word)

tuple(zip(numbers, word))

n = 3
for i in range(3):
    print(i)
    if i == n:
        break
else:
    print('Schleife wurde  NICHT vorzeitig verlassen')

n = 2

i = 0
while i < 3:
    print(i)
    if i == n:
        break
    i = i + 1
else:
    print('Schleife wurde  NICHT vorzeitig verlassen')

Loesung Aufg 2

s = 'abcdefgh'
n = len(s)
list(zip(s, range(n)))

def find_all(word, char):
    indices = ()
    i = -1
    for c in word:
        i = i + 1
        if c != char:
            continue
        indices = indices + (i,)
    return indices

def find_all(word, char):
    indices = ()
    for i, c in enumerate(word):
        if c != char:
            continue
        indices = indices + (i,)
    return indices

def find_all(word, char):
    indices = ()
    i = -1
    for c in word:
        i = i + 1
        if c != char:
            continue
        indices = indices + (i,)
    return indices

def find_all(word, char):
    indices = ()
    for i, c in enumerate(word):
        if c != char:
            continue
        indices = indices + (i,)
    return indices

Cheatsheet
  eigene Implementationen einiger Stringmethoden
  eigene Implementationen einiger Listmethoden

Notebookfinder

Kontrollfragen_06
